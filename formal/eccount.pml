

#define N_WRITER 2
#define N_READER 2
#define N_SNAPSHOT 4

typedef snapshot {
	short timestamp;
	bool allocated;
	short next;
	int counters[N_WRITER]
}

snapshot snapshots[N_SNAPSHOT];

/* To record the information of reader processes. */
typedef reader_info {
	byte id;
	byte timestamp; /* Timestamp value when the read request arrives. */
	int sum;
}

reader_info readers[N_READER];

/* Global variables */
byte g_timestamp;  /* Global shared timestamp */
short g_updating_snapshot;  /* Indicating counter array which updaters are incrementing */
short g_old_snapshots;  /* indicatting old shapshots list */
byte stop_flag;


/**********************************************************/
/*********** Linked list to record old snapshots **********/
/**********************************************************/

/* Users need to define variable *allocated_snapshot_id* before using this helper function. */
inline snapshot_malloc( )
{
	byte snapshot_ptr = 0;
	atomic {
	do
	:: (snapshot_ptr >= N_SNAPSHOT) -> 
		allocated_snapshot_id = -1; /* Error happens */
		break;
	:: else ->
		if
		:: ( !(snapshots[snapshot_ptr].allocated) ) ->
			snapshots[snapshot_ptr].allocated = 1;
			allocated_snapshot_id = snapshot_ptr;
			goto L1_mal;
		:: else -> 
			snapshot_ptr = snapshot_ptr + 1;
		fi
	od
L1_mal:	skip;
	} /* end of atomic */
}

inline snapshot_free(index)
{
	atomic {
		snapshots[index].timestamp = 0;
		snapshots[index].allocated = 0;
		snapshots[index].next = 0;
		snapshots[index].counters[0] = 0;
		snapshots[index].counters[1] = 0;
	}
}

/* Users need to define variable *sum* before using this helper function */
inline sumup_list(tsp)
{
	short ptr = g_old_snapshots;
	do
	:: ptr >= N_SNAPSHOT -> break;
	:: ptr == -1 -> break;
	:: else ->
		if
		:: (snapshots[ptr].timestamp > tsp) -> 
			/* Skip snapshots with larger timestamp values, which
			 * are generated by subsequent read requests. */
			ptr = snapshots[ptr].next;
		:: else ->
			sum = sum + snapshots[ptr].counters[0];
			sum = sum + snapshots[ptr].counters[1];
			ptr = snapshots[ptr].next;
		fi
	od
}


/*****************************************/
/***********  ECCount algorithm **********/
/*****************************************/

proctype writer(byte id)
{
	atomic {
	do
	:: stop_flag -> break;
	:: else ->
		snapshots[g_updating_snapshot].counters[id] ++; 
		skip;
	od
	} /* end atomic */
}

proctype reader(byte id)
{
	byte allocated_snapshot_id = 0;

	/* Atomically allocate a new snapshot */
	atomic {
		snapshot_malloc( );
		if
		:: (allocated_snapshot_id == -1) -> 
			printf("Error in allocating snapshot.\n");
		/*:: else ->
			printf("Successfully allocate snapshot %d\n",
				allocated_snapshot_id); */
		fi
	}

	byte tmp;
	/* (1) Swapping snapshots indicated by allocated_snapshot_id and
	 * g_updating_snapshot, and (2) incrementing timestamp value atomically.
	 * The primitive *atomic* in Promela is equivalent to the primitive FAA
	 * and SWAP on real servers. We perform FAA and SWAP in a single atomic
	 * block to save generated state space. */
	atomic {
		tmp = g_updating_snapshot;
		g_updating_snapshot = allocated_snapshot_id;

		snapshots[tmp].timestamp = g_timestamp;
		g_timestamp ++;
	}

	/* Insert the latest snapshot into global linked list */
	atomic {
		snapshots[tmp].next = g_old_snapshots;
		g_old_snapshots = tmp;
	}

	int sum;

	/* Sum up snapshots whose timestamp values are less than or equal to
	 * the timestamp value of this read request. */
	sumup_list(snapshots[tmp].timestamp);

	/* Fill in reader request info, which will be used to print summary. */
	readers[id].id = id;
	readers[id].sum = sum;
	readers[id].timestamp = snapshots[tmp].timestamp;

}

init 
{ 
	/* Initialization */
	atomic {
		snapshots[0].next = -1;
		snapshots[1].next = -1;
		snapshots[2].next = -1;
		snapshots[3].next = -1;
		g_old_snapshots = -1;
		/* snapshots[0] is by default assigned to
		 * global_updating_snapshot. */
		snapshots[0].allocated = 1;
	}

	atomic { run writer(0); run writer(1); }

	byte n;
	n = _nr_pr;
	run reader(0);
	run reader(1);
	(n == _nr_pr); /* To make sure the two reader requests have finished. */

	short result_ptr = g_old_snapshots;
	printf("Generated snapshots are as follows:\n");
	do
	:: (result_ptr >= N_SNAPSHOT) -> break;
	:: (result_ptr == -1) -> break;
	:: else ->
		printf("snapshot id: %d, timestamp: %d, allocated: %d, next snapshot id: %d, counters[0]: %d, counters[1]: %d\n",
			result_ptr,
			snapshots[result_ptr].timestamp,
			snapshots[result_ptr].allocated,
			snapshots[result_ptr].next,
			snapshots[result_ptr].counters[0],
			snapshots[result_ptr].counters[1]);
		result_ptr = snapshots[result_ptr].next;
	od

	/* Stop writers to avoid being overwhelmed by useless states. */
	stop_flag = 1;

	printf("Final result of reader %d. Timestamp: %d, sum: %d\n",
		readers[0].id, readers[0].timestamp, readers[0].sum);
	printf("Final result of reader %d. Timestamp: %d, sum: %d\n",
		readers[1].id, readers[1].timestamp, readers[1].sum);

	if
	:: (readers[0].timestamp < readers[1].timestamp) ->
		assert(readers[0].sum < readers[1].sum);
	:: (readers[0].timestamp > readers[1].timestamp) ->
		assert(readers[0].sum > readers[1].sum);
	:: (readers[0].timestamp == readers[1].timestamp) ->
		assert(readers[0].sum == readers[1].sum);
	fi
}


/* Helper function to test if the linked list works. */
/*
proctype check_list()
{

	byte ptr = 0;
	do
	:: ptr >= N_SNAPSHOT -> break;
	:: else ->
		printf("NUM %d, Allocated %d, Next %d\n", ptr, snapshots[ptr].allocated, snapshots[ptr].next);
		ptr++;
	od

	byte allocated_snapshot_id;
	snapshot_malloc( );
	byte ptr_buff1 = allocated_snapshot_id;
	snapshot_malloc( );
	byte ptr_buff2 = allocated_snapshot_id;

	ptr = 0;
	do
	:: ptr >= N_SNAPSHOT -> break;
	:: else ->
		printf("NUM %d, Allocated %d, Next %d\n", ptr, snapshots[ptr].allocated, snapshots[ptr].next);
		ptr++;
	od

	snapshot_free(ptr_buff1);
	snapshot_free(ptr_buff2);

	ptr = 0;
	do
	:: ptr >= N_SNAPSHOT -> break;
	:: else ->
		printf("NUM %d, Allocated %d, Next %d\n", ptr, snapshots[ptr].allocated, snapshots[ptr].next);
		ptr++;
	od
}	
*/
